### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type AggregateBatch {
  count: Int!
}

type AggregatePresence {
  count: Int!
}

type AggregateSocialAssistant {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type Batch {
  endTime: DateTime!
  id: ID!
  name: String!
  startingTime: DateTime!
}

type BatchConnection {
  aggregate: AggregateBatch!
  edges: [BatchEdge!]!
  pageInfo: PageInfo!
}

input BatchCreateInput {
  endTime: DateTime!
  id: ID
  name: String!
  startingTime: DateTime!
}

input BatchCreateOneInput {
  connect: BatchWhereUniqueInput
  create: BatchCreateInput
}

type BatchEdge {
  cursor: String!
  node: Batch!
}

enum BatchOrderByInput {
  createdAt_ASC
  createdAt_DESC
  endTime_ASC
  endTime_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  startingTime_ASC
  startingTime_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BatchPayload {
  count: Long!
}

input BatchUpdateDataInput {
  endTime: DateTime
  name: String
  startingTime: DateTime
}

input BatchUpdateInput {
  endTime: DateTime
  name: String
  startingTime: DateTime
}

input BatchUpdateManyMutationInput {
  endTime: DateTime
  name: String
  startingTime: DateTime
}

input BatchUpdateOneRequiredInput {
  connect: BatchWhereUniqueInput
  create: BatchCreateInput
  update: BatchUpdateDataInput
  upsert: BatchUpsertNestedInput
}

input BatchUpsertNestedInput {
  create: BatchCreateInput!
  update: BatchUpdateDataInput!
}

input BatchWhereInput {
  AND: [BatchWhereInput!]
  endTime: DateTime
  endTime_gt: DateTime
  endTime_gte: DateTime
  endTime_in: [DateTime!]
  endTime_lt: DateTime
  endTime_lte: DateTime
  endTime_not: DateTime
  endTime_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [BatchWhereInput!]
  OR: [BatchWhereInput!]
  startingTime: DateTime
  startingTime_gt: DateTime
  startingTime_gte: DateTime
  startingTime_in: [DateTime!]
  startingTime_lt: DateTime
  startingTime_lte: DateTime
  startingTime_not: DateTime
  startingTime_not_in: [DateTime!]
}

input BatchWhereUniqueInput {
  id: ID
  name: String
}

scalar DateTime

enum FinancialParticipation {
  EXTERN
  NO
  OTHER
  YES
}

scalar Long

type Mutation {
  createBatch(data: BatchCreateInput!): Batch!
  createPresence(data: PresenceCreateInput!): Presence!
  createSocialAssistant(data: SocialAssistantCreateInput!): SocialAssistant!
  createStudent(data: StudentCreateInput!): Student!
  deleteBatch(where: BatchWhereUniqueInput!): Batch
  deleteManyBatches(where: BatchWhereInput): BatchPayload!
  deleteManyPresences(where: PresenceWhereInput): BatchPayload!
  deleteManySocialAssistants(where: SocialAssistantWhereInput): BatchPayload!
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
  deletePresence(where: PresenceWhereUniqueInput!): Presence
  deleteSocialAssistant(where: SocialAssistantWhereUniqueInput!): SocialAssistant
  deleteStudent(where: StudentWhereUniqueInput!): Student
  updateBatch(data: BatchUpdateInput!, where: BatchWhereUniqueInput!): Batch
  updateManyBatches(data: BatchUpdateManyMutationInput!, where: BatchWhereInput): BatchPayload!
  updateManyPresences(data: PresenceUpdateManyMutationInput!, where: PresenceWhereInput): BatchPayload!
  updateManySocialAssistants(data: SocialAssistantUpdateManyMutationInput!, where: SocialAssistantWhereInput): BatchPayload!
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  updatePresence(data: PresenceUpdateInput!, where: PresenceWhereUniqueInput!): Presence
  updateSocialAssistant(data: SocialAssistantUpdateInput!, where: SocialAssistantWhereUniqueInput!): SocialAssistant
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  upsertBatch(create: BatchCreateInput!, update: BatchUpdateInput!, where: BatchWhereUniqueInput!): Batch!
  upsertPresence(create: PresenceCreateInput!, update: PresenceUpdateInput!, where: PresenceWhereUniqueInput!): Presence!
  upsertSocialAssistant(create: SocialAssistantCreateInput!, update: SocialAssistantUpdateInput!, where: SocialAssistantWhereUniqueInput!): SocialAssistant!
  upsertStudent(create: StudentCreateInput!, update: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Presence {
  dateEnd: DateTime!
  dateStart: DateTime!
  goodExcuse: Boolean
  id: ID!
  reason: String
  student: Student!
}

type PresenceConnection {
  aggregate: AggregatePresence!
  edges: [PresenceEdge!]!
  pageInfo: PageInfo!
}

input PresenceCreateInput {
  dateEnd: DateTime!
  dateStart: DateTime!
  goodExcuse: Boolean
  id: ID
  reason: String
  student: StudentCreateOneWithoutPresencesInput!
}

input PresenceCreateManyWithoutStudentInput {
  connect: [PresenceWhereUniqueInput!]
  create: [PresenceCreateWithoutStudentInput!]
}

input PresenceCreateWithoutStudentInput {
  dateEnd: DateTime!
  dateStart: DateTime!
  goodExcuse: Boolean
  id: ID
  reason: String
}

type PresenceEdge {
  cursor: String!
  node: Presence!
}

enum PresenceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  dateEnd_ASC
  dateEnd_DESC
  dateStart_ASC
  dateStart_DESC
  goodExcuse_ASC
  goodExcuse_DESC
  id_ASC
  id_DESC
  reason_ASC
  reason_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PresenceScalarWhereInput {
  AND: [PresenceScalarWhereInput!]
  dateEnd: DateTime
  dateEnd_gt: DateTime
  dateEnd_gte: DateTime
  dateEnd_in: [DateTime!]
  dateEnd_lt: DateTime
  dateEnd_lte: DateTime
  dateEnd_not: DateTime
  dateEnd_not_in: [DateTime!]
  dateStart: DateTime
  dateStart_gt: DateTime
  dateStart_gte: DateTime
  dateStart_in: [DateTime!]
  dateStart_lt: DateTime
  dateStart_lte: DateTime
  dateStart_not: DateTime
  dateStart_not_in: [DateTime!]
  goodExcuse: Boolean
  goodExcuse_not: Boolean
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [PresenceScalarWhereInput!]
  OR: [PresenceScalarWhereInput!]
  reason: String
  reason_contains: String
  reason_ends_with: String
  reason_gt: String
  reason_gte: String
  reason_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_not: String
  reason_not_contains: String
  reason_not_ends_with: String
  reason_not_in: [String!]
  reason_not_starts_with: String
  reason_starts_with: String
}

input PresenceUpdateInput {
  dateEnd: DateTime
  dateStart: DateTime
  goodExcuse: Boolean
  reason: String
  student: StudentUpdateOneRequiredWithoutPresencesInput
}

input PresenceUpdateManyDataInput {
  dateEnd: DateTime
  dateStart: DateTime
  goodExcuse: Boolean
  reason: String
}

input PresenceUpdateManyMutationInput {
  dateEnd: DateTime
  dateStart: DateTime
  goodExcuse: Boolean
  reason: String
}

input PresenceUpdateManyWithoutStudentInput {
  connect: [PresenceWhereUniqueInput!]
  create: [PresenceCreateWithoutStudentInput!]
  delete: [PresenceWhereUniqueInput!]
  deleteMany: [PresenceScalarWhereInput!]
  disconnect: [PresenceWhereUniqueInput!]
  set: [PresenceWhereUniqueInput!]
  update: [PresenceUpdateWithWhereUniqueWithoutStudentInput!]
  updateMany: [PresenceUpdateManyWithWhereNestedInput!]
  upsert: [PresenceUpsertWithWhereUniqueWithoutStudentInput!]
}

input PresenceUpdateManyWithWhereNestedInput {
  data: PresenceUpdateManyDataInput!
  where: PresenceScalarWhereInput!
}

input PresenceUpdateWithoutStudentDataInput {
  dateEnd: DateTime
  dateStart: DateTime
  goodExcuse: Boolean
  reason: String
}

input PresenceUpdateWithWhereUniqueWithoutStudentInput {
  data: PresenceUpdateWithoutStudentDataInput!
  where: PresenceWhereUniqueInput!
}

input PresenceUpsertWithWhereUniqueWithoutStudentInput {
  create: PresenceCreateWithoutStudentInput!
  update: PresenceUpdateWithoutStudentDataInput!
  where: PresenceWhereUniqueInput!
}

input PresenceWhereInput {
  AND: [PresenceWhereInput!]
  dateEnd: DateTime
  dateEnd_gt: DateTime
  dateEnd_gte: DateTime
  dateEnd_in: [DateTime!]
  dateEnd_lt: DateTime
  dateEnd_lte: DateTime
  dateEnd_not: DateTime
  dateEnd_not_in: [DateTime!]
  dateStart: DateTime
  dateStart_gt: DateTime
  dateStart_gte: DateTime
  dateStart_in: [DateTime!]
  dateStart_lt: DateTime
  dateStart_lte: DateTime
  dateStart_not: DateTime
  dateStart_not_in: [DateTime!]
  goodExcuse: Boolean
  goodExcuse_not: Boolean
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [PresenceWhereInput!]
  OR: [PresenceWhereInput!]
  reason: String
  reason_contains: String
  reason_ends_with: String
  reason_gt: String
  reason_gte: String
  reason_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_not: String
  reason_not_contains: String
  reason_not_ends_with: String
  reason_not_in: [String!]
  reason_not_starts_with: String
  reason_starts_with: String
  student: StudentWhereInput
}

input PresenceWhereUniqueInput {
  id: ID
}

type Query {
  batch(where: BatchWhereUniqueInput!): Batch
  batches(after: String, before: String, first: Int, last: Int, orderBy: BatchOrderByInput, skip: Int, where: BatchWhereInput): [Batch!]!
  batchesConnection(after: String, before: String, first: Int, last: Int, orderBy: BatchOrderByInput, skip: Int, where: BatchWhereInput): BatchConnection!
  presence(where: PresenceWhereUniqueInput!): Presence
  presences(after: String, before: String, first: Int, last: Int, orderBy: PresenceOrderByInput, skip: Int, where: PresenceWhereInput): [Presence!]!
  presencesConnection(after: String, before: String, first: Int, last: Int, orderBy: PresenceOrderByInput, skip: Int, where: PresenceWhereInput): PresenceConnection!
  socialAssistant(where: SocialAssistantWhereUniqueInput!): SocialAssistant
  socialAssistants(after: String, before: String, first: Int, last: Int, orderBy: SocialAssistantOrderByInput, skip: Int, where: SocialAssistantWhereInput): [SocialAssistant!]!
  socialAssistantsConnection(after: String, before: String, first: Int, last: Int, orderBy: SocialAssistantOrderByInput, skip: Int, where: SocialAssistantWhereInput): SocialAssistantConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(after: String, before: String, first: Int, last: Int, orderBy: StudentOrderByInput, skip: Int, where: StudentWhereInput): [Student!]!
  studentsConnection(after: String, before: String, first: Int, last: Int, orderBy: StudentOrderByInput, skip: Int, where: StudentWhereInput): StudentConnection!
}

enum Sexe {
  FEMALE
  MALE
  OTHER
}

type SocialAssistant {
  email: String
  firstName: String!
  id: ID!
  lastName: String!
  phone: String
}

type SocialAssistantConnection {
  aggregate: AggregateSocialAssistant!
  edges: [SocialAssistantEdge!]!
  pageInfo: PageInfo!
}

input SocialAssistantCreateInput {
  email: String
  firstName: String!
  id: ID
  lastName: String!
  phone: String
}

input SocialAssistantCreateOneInput {
  connect: SocialAssistantWhereUniqueInput
  create: SocialAssistantCreateInput
}

type SocialAssistantEdge {
  cursor: String!
  node: SocialAssistant!
}

enum SocialAssistantOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  phone_ASC
  phone_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input SocialAssistantUpdateDataInput {
  email: String
  firstName: String
  lastName: String
  phone: String
}

input SocialAssistantUpdateInput {
  email: String
  firstName: String
  lastName: String
  phone: String
}

input SocialAssistantUpdateManyMutationInput {
  email: String
  firstName: String
  lastName: String
  phone: String
}

input SocialAssistantUpdateOneInput {
  connect: SocialAssistantWhereUniqueInput
  create: SocialAssistantCreateInput
  delete: Boolean
  disconnect: Boolean
  update: SocialAssistantUpdateDataInput
  upsert: SocialAssistantUpsertNestedInput
}

input SocialAssistantUpsertNestedInput {
  create: SocialAssistantCreateInput!
  update: SocialAssistantUpdateDataInput!
}

input SocialAssistantWhereInput {
  AND: [SocialAssistantWhereInput!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  NOT: [SocialAssistantWhereInput!]
  OR: [SocialAssistantWhereInput!]
  phone: String
  phone_contains: String
  phone_ends_with: String
  phone_gt: String
  phone_gte: String
  phone_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_not: String
  phone_not_contains: String
  phone_not_ends_with: String
  phone_not_in: [String!]
  phone_not_starts_with: String
  phone_starts_with: String
}

input SocialAssistantWhereUniqueInput {
  id: ID
}

type Student {
  addressCanton: String!
  addressCity: String!
  addressNPA: Int!
  addressStreet: String!
  batch: Batch!
  birthday: DateTime!
  borrowLaptops: Boolean!
  financialParticipation: FinancialParticipation!
  financialParticipationComment: String
  firstName: String!
  foodCost: String
  id: ID!
  lastName: String!
  nationality: String!
  organisation: String
  pocoEmail: String
  presences(after: String, before: String, first: Int, last: Int, orderBy: PresenceOrderByInput, skip: Int, where: PresenceWhereInput): [Presence!]
  privateEmail: String
  residencePermit: String!
  sexe: Sexe!
  socialAssistant: SocialAssistant
}

type StudentConnection {
  aggregate: AggregateStudent!
  edges: [StudentEdge!]!
  pageInfo: PageInfo!
}

input StudentCreateInput {
  addressCanton: String!
  addressCity: String!
  addressNPA: Int!
  addressStreet: String!
  batch: BatchCreateOneInput!
  birthday: DateTime!
  borrowLaptops: Boolean!
  financialParticipation: FinancialParticipation!
  financialParticipationComment: String
  firstName: String!
  foodCost: String
  id: ID
  lastName: String!
  nationality: String!
  organisation: String
  pocoEmail: String
  presences: PresenceCreateManyWithoutStudentInput
  privateEmail: String
  residencePermit: String!
  sexe: Sexe!
  socialAssistant: SocialAssistantCreateOneInput
}

input StudentCreateOneWithoutPresencesInput {
  connect: StudentWhereUniqueInput
  create: StudentCreateWithoutPresencesInput
}

input StudentCreateWithoutPresencesInput {
  addressCanton: String!
  addressCity: String!
  addressNPA: Int!
  addressStreet: String!
  batch: BatchCreateOneInput!
  birthday: DateTime!
  borrowLaptops: Boolean!
  financialParticipation: FinancialParticipation!
  financialParticipationComment: String
  firstName: String!
  foodCost: String
  id: ID
  lastName: String!
  nationality: String!
  organisation: String
  pocoEmail: String
  privateEmail: String
  residencePermit: String!
  sexe: Sexe!
  socialAssistant: SocialAssistantCreateOneInput
}

type StudentEdge {
  cursor: String!
  node: Student!
}

enum StudentOrderByInput {
  addressCanton_ASC
  addressCanton_DESC
  addressCity_ASC
  addressCity_DESC
  addressNPA_ASC
  addressNPA_DESC
  addressStreet_ASC
  addressStreet_DESC
  birthday_ASC
  birthday_DESC
  borrowLaptops_ASC
  borrowLaptops_DESC
  createdAt_ASC
  createdAt_DESC
  financialParticipation_ASC
  financialParticipation_DESC
  financialParticipationComment_ASC
  financialParticipationComment_DESC
  firstName_ASC
  firstName_DESC
  foodCost_ASC
  foodCost_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  nationality_ASC
  nationality_DESC
  organisation_ASC
  organisation_DESC
  pocoEmail_ASC
  pocoEmail_DESC
  privateEmail_ASC
  privateEmail_DESC
  residencePermit_ASC
  residencePermit_DESC
  sexe_ASC
  sexe_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input StudentUpdateInput {
  addressCanton: String
  addressCity: String
  addressNPA: Int
  addressStreet: String
  batch: BatchUpdateOneRequiredInput
  birthday: DateTime
  borrowLaptops: Boolean
  financialParticipation: FinancialParticipation
  financialParticipationComment: String
  firstName: String
  foodCost: String
  lastName: String
  nationality: String
  organisation: String
  pocoEmail: String
  presences: PresenceUpdateManyWithoutStudentInput
  privateEmail: String
  residencePermit: String
  sexe: Sexe
  socialAssistant: SocialAssistantUpdateOneInput
}

input StudentUpdateManyMutationInput {
  addressCanton: String
  addressCity: String
  addressNPA: Int
  addressStreet: String
  birthday: DateTime
  borrowLaptops: Boolean
  financialParticipation: FinancialParticipation
  financialParticipationComment: String
  firstName: String
  foodCost: String
  lastName: String
  nationality: String
  organisation: String
  pocoEmail: String
  privateEmail: String
  residencePermit: String
  sexe: Sexe
}

input StudentUpdateOneRequiredWithoutPresencesInput {
  connect: StudentWhereUniqueInput
  create: StudentCreateWithoutPresencesInput
  update: StudentUpdateWithoutPresencesDataInput
  upsert: StudentUpsertWithoutPresencesInput
}

input StudentUpdateWithoutPresencesDataInput {
  addressCanton: String
  addressCity: String
  addressNPA: Int
  addressStreet: String
  batch: BatchUpdateOneRequiredInput
  birthday: DateTime
  borrowLaptops: Boolean
  financialParticipation: FinancialParticipation
  financialParticipationComment: String
  firstName: String
  foodCost: String
  lastName: String
  nationality: String
  organisation: String
  pocoEmail: String
  privateEmail: String
  residencePermit: String
  sexe: Sexe
  socialAssistant: SocialAssistantUpdateOneInput
}

input StudentUpsertWithoutPresencesInput {
  create: StudentCreateWithoutPresencesInput!
  update: StudentUpdateWithoutPresencesDataInput!
}

input StudentWhereInput {
  addressCanton: String
  addressCanton_contains: String
  addressCanton_ends_with: String
  addressCanton_gt: String
  addressCanton_gte: String
  addressCanton_in: [String!]
  addressCanton_lt: String
  addressCanton_lte: String
  addressCanton_not: String
  addressCanton_not_contains: String
  addressCanton_not_ends_with: String
  addressCanton_not_in: [String!]
  addressCanton_not_starts_with: String
  addressCanton_starts_with: String
  addressCity: String
  addressCity_contains: String
  addressCity_ends_with: String
  addressCity_gt: String
  addressCity_gte: String
  addressCity_in: [String!]
  addressCity_lt: String
  addressCity_lte: String
  addressCity_not: String
  addressCity_not_contains: String
  addressCity_not_ends_with: String
  addressCity_not_in: [String!]
  addressCity_not_starts_with: String
  addressCity_starts_with: String
  addressNPA: Int
  addressNPA_gt: Int
  addressNPA_gte: Int
  addressNPA_in: [Int!]
  addressNPA_lt: Int
  addressNPA_lte: Int
  addressNPA_not: Int
  addressNPA_not_in: [Int!]
  addressStreet: String
  addressStreet_contains: String
  addressStreet_ends_with: String
  addressStreet_gt: String
  addressStreet_gte: String
  addressStreet_in: [String!]
  addressStreet_lt: String
  addressStreet_lte: String
  addressStreet_not: String
  addressStreet_not_contains: String
  addressStreet_not_ends_with: String
  addressStreet_not_in: [String!]
  addressStreet_not_starts_with: String
  addressStreet_starts_with: String
  AND: [StudentWhereInput!]
  batch: BatchWhereInput
  birthday: DateTime
  birthday_gt: DateTime
  birthday_gte: DateTime
  birthday_in: [DateTime!]
  birthday_lt: DateTime
  birthday_lte: DateTime
  birthday_not: DateTime
  birthday_not_in: [DateTime!]
  borrowLaptops: Boolean
  borrowLaptops_not: Boolean
  financialParticipation: FinancialParticipation
  financialParticipation_in: [FinancialParticipation!]
  financialParticipation_not: FinancialParticipation
  financialParticipation_not_in: [FinancialParticipation!]
  financialParticipationComment: String
  financialParticipationComment_contains: String
  financialParticipationComment_ends_with: String
  financialParticipationComment_gt: String
  financialParticipationComment_gte: String
  financialParticipationComment_in: [String!]
  financialParticipationComment_lt: String
  financialParticipationComment_lte: String
  financialParticipationComment_not: String
  financialParticipationComment_not_contains: String
  financialParticipationComment_not_ends_with: String
  financialParticipationComment_not_in: [String!]
  financialParticipationComment_not_starts_with: String
  financialParticipationComment_starts_with: String
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  foodCost: String
  foodCost_contains: String
  foodCost_ends_with: String
  foodCost_gt: String
  foodCost_gte: String
  foodCost_in: [String!]
  foodCost_lt: String
  foodCost_lte: String
  foodCost_not: String
  foodCost_not_contains: String
  foodCost_not_ends_with: String
  foodCost_not_in: [String!]
  foodCost_not_starts_with: String
  foodCost_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  nationality: String
  nationality_contains: String
  nationality_ends_with: String
  nationality_gt: String
  nationality_gte: String
  nationality_in: [String!]
  nationality_lt: String
  nationality_lte: String
  nationality_not: String
  nationality_not_contains: String
  nationality_not_ends_with: String
  nationality_not_in: [String!]
  nationality_not_starts_with: String
  nationality_starts_with: String
  NOT: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  organisation: String
  organisation_contains: String
  organisation_ends_with: String
  organisation_gt: String
  organisation_gte: String
  organisation_in: [String!]
  organisation_lt: String
  organisation_lte: String
  organisation_not: String
  organisation_not_contains: String
  organisation_not_ends_with: String
  organisation_not_in: [String!]
  organisation_not_starts_with: String
  organisation_starts_with: String
  pocoEmail: String
  pocoEmail_contains: String
  pocoEmail_ends_with: String
  pocoEmail_gt: String
  pocoEmail_gte: String
  pocoEmail_in: [String!]
  pocoEmail_lt: String
  pocoEmail_lte: String
  pocoEmail_not: String
  pocoEmail_not_contains: String
  pocoEmail_not_ends_with: String
  pocoEmail_not_in: [String!]
  pocoEmail_not_starts_with: String
  pocoEmail_starts_with: String
  presences_every: PresenceWhereInput
  presences_none: PresenceWhereInput
  presences_some: PresenceWhereInput
  privateEmail: String
  privateEmail_contains: String
  privateEmail_ends_with: String
  privateEmail_gt: String
  privateEmail_gte: String
  privateEmail_in: [String!]
  privateEmail_lt: String
  privateEmail_lte: String
  privateEmail_not: String
  privateEmail_not_contains: String
  privateEmail_not_ends_with: String
  privateEmail_not_in: [String!]
  privateEmail_not_starts_with: String
  privateEmail_starts_with: String
  residencePermit: String
  residencePermit_contains: String
  residencePermit_ends_with: String
  residencePermit_gt: String
  residencePermit_gte: String
  residencePermit_in: [String!]
  residencePermit_lt: String
  residencePermit_lte: String
  residencePermit_not: String
  residencePermit_not_contains: String
  residencePermit_not_ends_with: String
  residencePermit_not_in: [String!]
  residencePermit_not_starts_with: String
  residencePermit_starts_with: String
  sexe: Sexe
  sexe_in: [Sexe!]
  sexe_not: Sexe
  sexe_not_in: [Sexe!]
  socialAssistant: SocialAssistantWhereInput
}

input StudentWhereUniqueInput {
  id: ID
}
